# heFFTe重构技术决策文档

## 核心问题

在研究heFFTe库并尝试重构代码时，发现了一个根本性的技术挑战：

### 当前算法结构

你的代码使用**混合FFT策略**：

```
实空间数据 V(x,y,z)
    ↓
z方向R2R变换 (DCT/DST, 局部, 无MPI)  → V_z(x,y,k_z) [实数]
    ↓
xy平面R2C变换 (MPI并行, 2D FFT + 批处理) → V_spec(k_x,k_y,k_z) [复数]
    ↓
频谱空间操作
```

### heFFTe的设计

heFFTe是为**完整3D FFT**设计的库：
- 输入：3D实数或复数数组
- 输出：3D复数数组（频谱）
- 所有三个方向同时进行FFT变换

### 不匹配之处

**你的算法**：
- z方向：R2R变换（DCT/DST）
- xy平面：标准FFT（R2C）
- 是**分阶段**的变换

**heFFTe**：
- 设计用于所有方向统一的3D FFT
- 主要优化针对C2C（复数到复数）或R2C（3D实到复数）
- 不直接支持"部分维度R2R + 其他维度FFT"的混合模式

---

## 三种可行方案

### 方案A：保守方案 - 保留FFTW（推荐短期）

**策略**：
- 不使用heFFTe
- 继续使用FFTW MPI
- z方向：FFTW R2R（局部）
- xy平面：FFTW MPI R2C（分布式，Slab分解）

**优点**：
- ✅ 零风险，代码已验证正确
- ✅ 无需重构
- ✅ 快速完成课程作业

**缺点**：
- ❌ 无法获得heFFTe的性能优势
- ❌ 仍受Slab分解的可扩展性限制（进程数≤N）
- ❌ 论文创新性不足

**适用场景**：
- 时间紧迫，需要快速完成阶段性成果
- 先完成调研报告，代码重构作为后续工作

**工作量**：无（保持现状）

---

### 方案B：混合方案 - P3DFFT替换xy平面（推荐中期）

**策略**：
- 不使用heFFTe（因为不适合当前算法）
- **使用P3DFFT库替换xy平面的FFT**
- z方向：继续用FFTW R2R
- xy平面：P3DFFT（支持Pencil分解）

**为什么用P3DFFT而不是heFFTe？**

P3DFFT更适合你的场景：
1. **显式支持2D FFT + 批处理**
   - P3DFFT可以指定在特定平面做FFT
   - 第三个维度可以作为批处理

2. **成熟稳定**
   - 2012年发布，有大量使用案例
   - 文档完善，示例丰富

3. **Pencil分解**
   - 解决了可扩展性问题（O(N²) vs O(N)）
   - 这是核心目标

**实施步骤**：

1. 在MGU-270上安装P3DFFT
2. 修改初始化代码：
   ```cpp
   // 原来
   plan_fwd_r2c_cos = fftw_mpi_plan_many_dft_r2c(2, nn1, nz_int, ...);

   // 改为
   p3dfft_setup();  // 初始化P3DFFT
   plan_fwd_cos = p3dfft_plan_3d(..., P3DFFT_R2CFFT_XY, ...);
   // 指定只在XY平面做FFT，Z方向保留
   ```

3. 修改FFT执行：
   ```cpp
   // 原来
   fftw_mpi_execute_dft_r2c(plan_fwd_r2c_cos, re_in, complex_out);

   // 改为
   p3dfft_exec_3d(plan_fwd_cos, re_in, complex_out);
   ```

**优点**：
- ✅ Pencil分解，可扩展性提升到O(N²)
- ✅ 优化的MPI通信
- ✅ 改动相对较小（只改xy平面部分）
- ✅ 保持数学正确性
- ✅ 有明确的性能提升

**缺点**：
- ⚠️ 需要学习P3DFFT API
- ⚠️ 需要处理数据布局转换
- ⚠️ 仍然不是最新的库（但很稳定）

**工作量**：中等（2-3周）

**预期性能提升**：
- 64进程：1.5-2x
- 256进程：2-3x
- 1024进程：3-5x

---

### 方案C：完全重构 - 使用heFFTe的3D FFT（推荐长期）

**策略**：
- **重新设计算法**，放弃混合R2R+R2C策略
- 使用heFFTe的3D C2C或R2C变换
- 通过数学技巧实现DCT/DST边界条件

**理论基础**：

DCT和DST可以通过标准FFT实现：

1. **DCT通过FFT实现**：
   ```
   对于信号x[0..N-1]，构造对称扩展：
   y[0..2N-1] = [x[0], x[1], ..., x[N-1], x[N-2], ..., x[1]]

   DCT(x) = Re(FFT(y))[0..N-1]
   ```

2. **DST通过FFT实现**：
   ```
   对于信号x[0..N-1]，构造反对称扩展：
   y[0..2N-1] = [0, x[0], x[1], ..., x[N-1], 0, -x[N-1], ..., -x[1]]

   DST(x) = Im(FFT(y))[1..N]
   ```

**实施方案**：

1. **数据扩展**：
   - 在z方向对数据进行对称/反对称扩展
   - V1,V2: 偶对称扩展（用于DCT）
   - V3: 奇对称扩展（用于DST）
   - 扩展后数组大小翻倍

2. **使用heFFTe 3D C2C**：
   ```cpp
   // 完整3D FFT
   heffte::fft3d<heffte::backend::fftw> fft_3d(
       inbox, outbox, MPI_COMM_WORLD, options
   );

   fft_3d.forward(real_extended, complex_spectrum);
   ```

3. **提取DCT/DST结果**：
   - 从FFT结果中提取实部/虚部
   - 根据对称性只保留一半数据

**优点**：
- ✅ 完全利用heFFTe的优化（最佳性能）
- ✅ 支持GPU加速
- ✅ 论文创新性强
- ✅ 统一的3D FFT框架

**缺点**：
- ❌ 工作量大（需要1-2个月）
- ❌ 需要重新推导和验证数学
- ❌ 数据扩展导致内存和计算量翻倍
- ❌ 复杂度高，调试困难

**工作量**：大（1-2个月全职）

**内存开销**：2x（z方向扩展）

**计算开销**：
- FFT计算：~2x（数据翻倍）
- 但通信效率提升可能抵消部分开销

---

## 推荐实施路线图

### 第一阶段（当前）：完成调研

**时间**：1-2周

**任务**：
1. ✅ 已完成heFFTe调研
2. ✅ 已完成现有代码分析
3. 📝 准备PPT汇报
4. 📝 撰写技术决策文档（本文档）

**成果**：
- 向导师汇报三种方案的优缺点
- 获得导师对方案选择的指导
- 完成课程阶段性要求

---

### 第二阶段（课程作业期）：实施方案B

**时间**：2-3周

**原因**：
- 平衡了创新性和可行性
- 有明确的性能提升
- 工作量适中
- 风险可控

**任务**：
1. 安装和测试P3DFFT
2. 重写xy平面的FFT初始化和执行
3. 验证正确性
4. 性能测试和对比
5. 撰写实验报告

**成果**：
- 可工作的P3DFFT版本
- 性能对比数据
- 完成课程作业
- 为硕士论文奠定基础

---

### 第三阶段（硕士论文期）：方案C或GPU扩展

**时间**：硕士第一学期

**选择A**：完全heFFTe重构（方案C）
- 重新设计算法
- 通过FFT实现DCT/DST
- 完全利用heFFTe优化

**选择B**：GPU加速（基于方案B）
- 保持P3DFFT+FFTW CPU版本
- 移植到GPU（CUDA）
- 使用cuFFT或P3DFFT的GPU版本

**导师意见**：需要讨论

---

## 技术细节：为什么heFFTe不直接适用

### heFFTe的典型用例

```cpp
// 用例1: 3D R2C变换（所有方向都是FFT）
heffte::fft3d_r2c<backend::fftw> fft(inbox, outbox, comm);
// 输入：3D实数 [nx][ny][nz]
// 输出：3D复数 [nx][ny][nz/2+1]（利用Hermitian对称性）

// 用例2: 3D C2C变换
heffte::fft3d<backend::fftw> fft(inbox, outbox, comm);
// 输入：3D复数 [nx][ny][nz]
// 输出：3D复数 [nx][ny][nz]
```

### 你的代码需要

```cpp
// 混合变换
// 步骤1: z方向R2R（DCT）
for each (x,y):
    DCT_z(V[x][y][:]) -> V_transformed[x][y][:]

// 步骤2: xy平面R2C（标准FFT）
for each z:
    FFT_xy(V_transformed[:,:][z]) -> V_spectrum[:,:][z]
```

**问题**：heFFTe没有"先在一个维度做R2R，然后在其他维度做FFT"的API。

### P3DFFT为什么更合适

P3DFFT允许指定变换类型：

```fortran
! P3DFFT可以指定
call p3dfft_setup(dims, nx, ny, nz, MPI_COMM_WORLD,
                  nx_cut, ny_cut, .true.,  ! Pencil分解
                  memsize)

! 可以创建只在特定平面的变换
call p3dfft_plan_3d(plan, nx, ny, nz,
                    P3DFFT_R2CFFT_XY,  ! 只在XY平面做FFT
                    P3DFFT_CFFT_FORWARD)
```

---

## 与导师讨论的问题清单

在你与导师下次讨论时，建议询问：

1. **方案选择**：
   - 短期目标（课程作业）倾向哪个方案？
   - 长期目标（硕士论文）的方向？
   - 是否需要GPU加速？

2. **时间规划**：
   - 课程作业的deadline？
   - 是否有中期检查点？

3. **性能目标**：
   - 期望的加速比是多少？
   - 最关心的指标（可扩展性 vs 绝对速度）？

4. **创新性要求**：
   - 硕士论文需要多大创新性？
   - 使用成熟库（P3DFFT）是否足够？
   - 还是必须使用最新库（heFFTe）？

5. **技术支持**：
   - MGU-270上是否已安装P3DFFT？
   - 是否有往届学生的代码可参考？
   - 是否有超算中心的技术支持？

---

## 我的建议

基于你的情况（硕士生，有课程作业要求），我建议：

### 当前（下次汇报前）

1. **准备PPT**展示三种方案
   - 方案A：保持现状（baseline）
   - 方案B：P3DFFT（推荐）
   - 方案C：完全heFFTe重构（长期）

2. **准备demo代码**
   - 下载并编译P3DFFT
   - 运行P3DFFT的示例程序
   - 展示P3DFFT可行性

3. **预估性能**
   - 引用P3DFFT论文的性能数据
   - 估算你的代码的预期加速比

### 导师同意后

**如果选方案B（P3DFFT）**：

第1周：
- [ ] 深入学习P3DFFT文档和API
- [ ] 在MGU-270上安装和测试P3DFFT
- [ ] 编写简单测试程序验证正确性

第2周：
- [ ] 修改代码，集成P3DFFT
- [ ] 保留FFTW作为对照
- [ ] 单元测试和正确性验证

第3周：
- [ ] 性能测试（不同规模，不同进程数）
- [ ] 数据分析和可视化
- [ ] 撰写报告

**如果选方案C（heFFTe）**：

需要更长时间（4-8周），分多个里程碑。

---

## 总结

**核心发现**：
- heFFTe不直接适用于当前的混合R2R+R2C算法
- P3DFFT更适合，可以达到主要目标（Pencil分解，可扩展性）
- 完全heFFTe重构需要重新设计算法

**推荐路径**：
1. 短期：P3DFFT（方案B）
2. 长期：考虑完全重构或GPU（方案C或GPU扩展）

**下一步**：
- 与导师讨论方案选择
- 根据导师建议启动实施

**我可以帮你**：
- 如果选P3DFFT：帮你编写集成代码
- 如果选heFFTe重构：帮你推导数学和编写代码
- 准备PPT和汇报材料
