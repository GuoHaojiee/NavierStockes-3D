то я... Я просто... Почему взял такой тайм-аут, да, на раздумья? Потому что, ну, понятно, что можно вот просто продолжить вашу задачу, которая была в поклавриате, как бы, да, но как бы хотелось что-то такое более интересное придумать, вот. Ну, в плане того, что вот Может быть, и вам это было бы интересно, и мне было бы интересно, ну и вообще было бы какое-то развитие вот этого всего дела. Значит, что, в общем, я предлагаю. Смотрите, ну вот, что сделал там Йоанн Думлян, допустим, к ГТА, у него же была похожая задача под Гавриати, только у него было не уравнение на въезд токса, а у него было уравнение магнитной индукции. То есть, вот дальше, значит, под Гавриати он что сделал? переписал, по сути, вот эту программу на граф-карты и, соответственно, параллельно, как бы, да, то есть, ну, собственно, одну карту переписал, потом переписал на несколько граф-карт, как бы, да, такая вот, и померил производительность, как бы, на нескольких граф-картах, а потом еще параллельно Исследовал производительность как бы, ну, своей же, опять же, СПУ-версии на ГУ-270. Ну, там тоже как раз вот та самая история, что для MPI-версии, да, можно использовать FFTW, ну, то, что и вы делали, да. А можно, как я вам уже говорил, да, там использовать P3DFFTab, то есть, которая, в чем у них принципиальные отличия, да, у них принципиальные отличия в том, что FFTW, оно все режет такими слоями, да, и вы, соответственно, эти слои как бы разбрасываете, ну, такие двумерные, как бы, да, вы их разбрасываете по узлам, ну, куски из этих слоев, да.

Speaker B
Понятно, о чем говорю? Ну, не очень.

Speaker C
Ну, можно потом еще раз.

Speaker A
То, что вы делали, то, что делает FFT, W, она берет вот этот кубик и его режет на кусочки. Этот кусочек нам процессу P0, этот P1, этот P2. Теперь вот каждый из этих кусочков он обрабатывается независимо, а потом происходят вот эти коммуникации, то есть вот по двум компонентам, вот по вот этим, скажем допустим Z и по Y происходит локальное провязание Fourier, нам ничего не надо, а вот по X нам нужно уже вот эти коммуникации, то есть по сути мы должны там перетрансформировать данные, помните вот это все. Так работает FFTW. Но, понятно, что у этого подхода есть серьезные ограничения. Ну, что у вас, вот заявление написано. Насколько я помню, ограничения какое? То есть, если, допустим, у нас вот Если, допустим, у нас 64, 64, 64, то у нас n должно быть меньше 64, правильно? Потому что мы не можем использовать больше, чем 64 процесса, потому что тогда у нас просто нет столько слоев.

Speaker D
Правильно?

Speaker A
Вот. А если говорить про... Ну, для полос, то нам на полосе больше не надо. Если говорить про Emu270, например, или даже про Luminous 2, то что у нас доступно, или вообще про другие суперкомпьютеры в мире, то конечно это плохо, потому что понятно, что... В том же MGU-270 там на одном усле только 128 ядер, то есть мы можем 128 процессов запустить, не говоря о том, что таких услов там тоже много, штук 40 есть. По этой причине уже давно придумали другое решение, то есть резать не слоями, А называется Pencil Decomposition. Резать вот такими карандашами. Разбиваем область и каждый процесс получает вот такой карандаш. Каждый будет получать вот такой карандашик. То есть мы режем не в одной плоскости, как здесь, а мы режем в двух плоскостях на самом деле. И вот получается у нас, соответственно, каждый процесс получает вот такой карандашик. Понятно, что это приводит к большим коммуникациям, но с другой стороны это позволяет увеличить масштабируемость. Тогда у вас ограничение здесь будет уже на число процессов, 64 в квадрате. И это хорошо, потому что в реальности 64 на 64 маленькие никому не интересно. Допустим 1024 там, да?

Speaker B
1024, 1024.

Speaker A
Ну а тут ограничения там на 1024 в кубе и в квадрате тоже много. Словно бы вряд ли. Ну вот P3DFFT в частности так и делает. Но встает вопрос, значит на самом-то деле, на самом деле и вот это довольно серьезная проблема, то что действительно там, с коммуникациями. Число коммуникаций в таких случаях может возрастать. Вот. И поэтому, что я предлагаю вам, скажем, взять в качестве задачи, ну и потом ее на самом деле развить, да? И то, что как раз вот Юанни, наверное, в общем не успел сделать в свое время, да? Это поисследовать вообще библиотеки.

Speaker B
Исследовать библиотеки.

Speaker A
Которые делают FFT.

Speaker C
То есть, нужно сам написать?

Speaker A
Нет, не надо самому писать. Нужно найти из имеющихся самую быстроработающую. То есть, на самом деле, что мы на сегодняшний день знаем? На сегодняшний день знаем, что если дело касается обычного преобразования Fourier в рамках одного узла, Ну или там последовательной версии какой-то, если говорить про последовательную версию, то де-факто все побеждают FFT Double. Вот, то есть даже там FFT заточенный под определенные процессоры, например как там ESSL, как вот у нас есть на полосе, да, который заточен, написан IBM-овскими программистами и оптимизирован под IBM-овские процессоры. Или там MKL, которое написано программистами Intel и оптимизировано под процессорами Intel. Как правило не дает лучшую производительность. То есть FTW она как бы более такая общая, она под любую архитектуру работает. А вот даже специализированные библиотеки, которые на самом деле должны побеждать, поскольку они как правило работают под определенную архитектуру, уже считают ее особенности и так далее, ну кого там кардинального улучшения нет, ну чуть-чуть да. Чуть-чуть лучше может быть где-то, но принципиально нет. За счет чего? За счет того, что FFTW как раз использует вот эту процедуру планирования. То есть вы делаете план, что происходит. На самом деле они делают очень интересную вещь. То есть они, по сути, сделали такие очень хорошо оптимизированные кирпичики, из которых они собирают свою вот эту FFTW, последнюю версию. А дальше вот этот план что он делает? Он пытается подобрать параметры для вашей конкретной архитектуры, какие параметры грубо говоря надо использовать с тем, чтобы получалась наилучшая производительность. То есть вы когда помните, вы использовали там estimate, есть там measure и так далее. Просто на самом деле вопрос того, насколько насколько хорошо оно подбирает эти параметры. То есть, если тиммейт примерно чуть-чуть их подберет быстренько и так как-нибудь, межер будет более, который там последний, я уже не помню, как это называется, еще больше, то есть, по сути, проводит эксперимент, подбирает эти параметры. Ну, конечно, чем лучше вы подбираете эти параметры различные, тем лучше получится производительность. И поэтому в последней версии Как бы ответ известен. То есть FFTW это лучше всего. А вот распределенная версия... Алло.

Speaker D
Да.

Speaker B
Занят. Да, перезвоню.

Speaker A
Ну, через полчаса где-то. А вот распределенная версия, тут FFTW не лучше. То есть, вот тут она the best, да, а вот тут нет. То есть, тут она не лучше просто потому, что она использует вот этот вариант распределения по слоям. И это, очевидно, имеет проблемы. И вот здесь какая версия лучше? У самих много разных версий. Если там посмотрите, вот P3-DFFT, который я упоминал, это одна из них, да, там есть еще и P3-DFFT+, что-то на фартране, по-моему, написано, это, по-моему, на плюсах, есть просто еще PFFT, да. Ну, то есть, короче, разных, много разных, да, как бы вот этих версий, которые, к сожалению, что делают? Они, по сути, решают проблему вот этих коммуникаций.

Speaker C
А эта библиотека... Не питонский? Это на fartran написано?

Speaker A
Нет, это на fartran написано. Но у него есть и инферфейс, но она вообще написана на fartran. По-моему, FFT там плюс-плюс, оно уже на плюсах. Еще есть просто PFFT, это по-моему на C. Ну, в общем, и не только они, на самом деле. Значит, они что? Они, как правило, внутри себя для вот этих коммуникаций последовательных, потому что в любом случае вот вы внутри этого карандаша будете делать какие-то последовательные коммуникации, правильно? То есть вот каждый процесс получает свой карандаш или вот эту плоскость, и там уже он делает по сути последовательную версию.

Speaker D
Правильно? Каждый.

Speaker A
Ну для своей счастья, а потом пойдут коммуникации. И вот эту последовательную часть все равно у вас делает FFT Double, поскольку он лучше всех. Ну или там другие библиотеки, они позволяют там условно говоря подбирать, то есть не FFTW, допустим Intel MKL или там тоже ESSL, вот там P3D FFT, например, он работает с двумя, либо FFTW, либо ESSL. Там MKL, он будет работать условно с своим Intel, например, да, либо там FFTW тоже. То есть, называется backend. То, что выступает в качестве backend. То, что используется для последовательного преобразования Foggy на каждом процессе. Вот тут будет выступать FFTW или какая-то из. У нас, поскольку доступен FFTW, мы по-моему всегда FFTW используем. А вот коммуникация-то. Как организовать коммуникацию? Тоже же на самом-то деле такой вопрос. Каждая библиотека может решать немножко по-разному. И поскольку магистрская диссертация обязательно должна иметь исследовательскую компоненту, я предлагаю в качестве исследования как раз провести, начая с того, чтобы вообще определить, а какая из FFT распределенных. Нас интересует распределенная FFT, потому что Споследовательно понятно, кто лучше всех OpenMP. В общем, там по большому счету не так интересно, кто там лучше всех. Ну, потому что в рамках одного узла редко кто считает. В основном, такие серьезные вычисления это, конечно, много. Много узлов, а это значит, что у вас вот это должна быть... Вот. Ну, MPI-ная какая-то поддержка FFT, да? То есть, вот какая из MPI-ных версий Начать с того, какие вообще существуют, поисследовать. Во-вторых, посмотреть, какие существуют. Я вам некоторые назвал, беру по не все, которые есть. Их, вообще говоря, много. Какие существуют, как работают, идейно. Там про каждый бюллетек все равно можно найти в чем их особенность. Что они там, как они коммуникации там.

Speaker B
Пытаются организовать, как они там пытаются перекрыть.

Speaker A
Коммуникации за вычислениями и так далее. Ну, кажется, что-то дело, как бы, да?

Speaker D
Вот.

Speaker A
Второе, какие публикации, которые сравнивают производительность? производительность существует. Разных MPI FFT существует. Ну и соответственно для чего все это нужно. То есть мы посмотрим может быть какие-то лучшие версии. Установим на том же MGU-270. И попробуем потестировать на нашем железе, потому что на нашем железе все равно же никто не тестирует. И это в любом случае будет интересно. Почему? Потому что понятно, что если мы найдем, что у вас по сути код вашей империальной версии, это же по сути большую часть работы делает FFT. Да, вы сделали, то есть там еще можно, немножко можно оптимизировать, но все равно главное у вас, что это FFT? Поэтому если мы найдем лучшую FFT-версию, ну значит мы сможем ускорить ваш код. Ну а в частности там, да, сможем понять, какой вообще надо использовать. Вот именно как распределенный. Вот какой последовательный, понятно. Вот какой распределенный, как бы, это вопрос. Ну вот как такая установка задачи? Она вроде бы и понятная. Тут вроде где есть, что последовать.

Speaker C
Он.

Speaker A
По сути исследовал только две библиотеки, он исследовал FFTW и он исследовал вот это 3D-FFT. Еще раз повторю, у него-то упор был.

Speaker D
На.

Speaker A
И для сравнения результата с граф-картами, ну, интересно было, конечно, понять, как это коррелирует с тем, что есть для центральных процессоров. Ну, и там все-таки, поскольку понятно, что граф-карты у всех побеждали, понятно, что для МГУ-270 в этой FFT Devil-U имел вот эти ограничения, и там надо было вот для больших значений использовать B3D FFT. Ну, он вот это сделал. Да, там действительно по 3D FFT для большого числа процессов лучше, чем FFT W, но это как раз был ожидаемый результат. Но опять же, там мы не ставили задачу, у нас просто времени уже не хватало исследовать более широко эти FFT W. В принципе, здесь как развитие и вот этой дальнейшей работы, Ну, то есть уже там на магистрскую диссертацию, да? Собственно, вот это скорее там на курсовую, да? То есть там преследовать, там посмотреть, как это все будет. А дальше, значит, там что можно сделать? Можно перейти тоже на граф-карты. Ну, то есть опыту Юаня Думляна, на самом деле, он же, в общем, там довольно большую работу проделал. Ну, вот как по запуску на МГУ-270, он как бы там... Разобрался, как запускать. Так сложно запускать. Ну как, есть четкая понятная инструкция, что надо делать. Когда она уже есть, запускать легко. А когда вы не знаете эту инструкцию, запускать сложно. Вот он месяц потратил только на то, чтобы правильно подобрать на себе параметры. Ну а сейчас как бы все это есть, как бы просто берете и запускаете. То есть сама инструкция есть от него, как надо сделать, чтобы все запустить. Ну я это вам все дам, как бы там расскажу, это вы не переживайте, как бы несложно. Ну что-то мы вместе с ним делали, что-то он там много сам он делал, ну там где он не мог, я ему помогал.

Speaker D
Вот.

Speaker A
То есть в принципе он с граф-картами то же самое, в принципе там что, он использовал кудой-то, да, кудой. То есть, там были с ней тоже сложности, но опять же, условно говоря, он их там все преодолел. То есть, опять же, его код есть. Могу, наверное, вам его дать. То есть, если мы потом перейдем на графкарты. То есть, вы условно переделаете это под свою задачу. То есть, опять же, самая сложность это, естественно, приобретение Fourier. Как вы только ее решаете, дальше там все, условно говоря, не так сложно. Вот он это все проблемы решил. Вот, а что было бы интересно дальше в смысле развития как бы, да, это перейти, то есть он что сделал, он сделал на одной GPU, да, потом он сделал на нескольких GPU, но на одном узле, да. Вот, а теперь как бы интересно перейти на N узлов, на M GPU, да, следующий шаг. Тоже есть библиотека соответствующая, там CUDA, на там CUDA. МФФТ, что ли называется? Не помню точно. Ну и тоже библиотека, по сути. Тут просто надо разобраться, как работает библиотека, потому что она, по большому счету, делает все за вас. Как только вы это поняли, как работает библиотека, там дальше все остальное делать не очень сложно. То есть здесь у него опыт есть, я думаю. Я думаю, что... Ну, это опять же, это вот уже потом. Сначала давайте с этим разберемся.

Speaker C
Сначала нужно, то есть, сначала, какие... Да.

Speaker A
То есть, вот допустим, посмотреть, да, ну, может быть, к этому деньку не успеть.

Speaker B
Но к следующему хотя бы, да, то.

Speaker A
Есть, какие есть вообще FFT, какие вот просто библиотеки, ну, докладик сделать, да, какие есть FFT, какие они там бывают, как они работают, принцип работы, да, то есть, так или иначе они будут использовать вот это карандашное разбиение в основном, да, pencil decomposition, то, что по-английски пишется. И, соответственно, но коммуникацию они немножко будут по-разному строить, потому что все борются за вот эти вот коммуникации, как это сделать наиболее оптимально. Ну и посмотрите вот эти работы, какие еще публикации, какие статьи есть. Наверняка же кто-то сравнивал эти как бы MPI версии FFT на своей какой-то архитектуре, ну вот чтобы понять, что примерно у нас так получается. Исследовательская работа, которая должна обязательно быть, ну дальше мы какие-то выберем, будем тоже на них смотреть, может что-то интегрируем в ваш код из этого. Потому что понятно, что FFT давно, U придется уходить. То есть на бакаловскую работу это было нормально, ну на магистрскую надо уже вот что-то такое.

Speaker C

